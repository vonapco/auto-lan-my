---
description: 
globs: 
alwaysApply: true
---
Отлично. Основываясь на анализе всей нашей предыдущей работы и допущенных ошибок, я сформулировал четыре ключевых правила для AI. Эти правила направлены на предотвращение повторения проблем, с которыми мы столкнулись, особенно с нарушением логики публикации сервера.

Правила для Cursor AI при работе с модами Minecraft (Fabric)

Эти правила должны строго соблюдаться при модификации кода, взаимодействующего с жизненным циклом сервера, асинхронными операциями и состоянием мира.

Правило №1: Строго соблюдать контекст потоков выполнения (Threading Context)

Принцип: Операции, изменяющие состояние сервера, выполняются только в потоке сервера. Операции, изменяющие GUI или состояние клиента, выполняются в потоке клиента.

Обоснование: Самая критическая ошибка, которая привела к отказу публикации сервера, заключалась в попытке выполнить серверную операцию (publishServer) из клиентского потока. Асинхронный CompletableFuture завершался и вызывал callback через MinecraftClient.getInstance().execute(), что планировало задачу для потока клиента, у которого нет прав на изменение состояния сервера.

Запрещенная практика:

Generated java
// НЕПРАВИЛЬНО: Попытка изменить сервер из клиентского потока
completableFuture.thenRun(() -> {
    MinecraftClient.getInstance().execute(() -> {
        server.publishServer(...); // Это вызовет ошибку или будет проигнорировано
    });
});


Обязательная практика:

Generated java
// ПРАВИЛЬНО: Передача экземпляра сервера и выполнение задачи в его потоке
completableFuture.thenRun(() -> {
    server.execute(() -> {
        server.publishServer(...); // Этот код будет выполнен корректно
    });
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

Контрольный список для AI:

Какую сущность изменяет мой код: сервер или клиентский интерфейс?

Если сервер (мир, игровые правила, игроки) -> использовать server.execute().

Если клиент (GUI, чат) -> использовать MinecraftClient.getInstance().execute().

Правило №2: Использовать наиболее подходящее событие жизненного цикла

Принцип: Выбирать событие, которое происходит в самый поздний, но все еще подходящий момент, чтобы гарантировать полную инициализацию всех зависимостей.

Обоснование: Многочисленные ошибки NullPointerException возникали из-за попыток получить доступ к миру или менеджеру состояний на слишком ранних этапах (createWorlds, SERVER_STARTED), когда они еще не были готовы.

Запрещенная практика: Использовать ServerLifecycleEvents.SERVER_STARTED для логики, требующей полного входа игрока в мир.

Обязательная практика: Использовать ClientPlayConnectionEvents.JOIN для логики, которая должна сработать после загрузки одиночного мира и появления в нем игрока. Это финальный и самый надежный этап.

Контрольный список для AI:

Требует ли моя логика, чтобы игрок был в мире? -> ClientPlayConnectionEvents.JOIN.

Требует ли моя логика очистки при выходе из мира? -> ServerLifecycleEvents.SERVER_STOPPING.

Нужно ли мне просто знать, что сервер запущен, без игрока? -> ServerLifecycleEvents.SERVER_STARTED.

Правило №3: Декаплировать управление состоянием во избежание "состояния гонки"

Принцип: Компоненты (например, агент) не должны самостоятельно отслеживать глобальные события, если их жизненный цикл управляется этими же событиями. Управление состоянием должно быть централизовано.

Обоснование: Проблема с неотправкой данных на главный сервер возникла из-за "состояния гонки": агент создавался внутри обработчика JOIN и в своем конструкторе пытался подписаться на это же событие. Его подписка не успевала сработать, и он оставался в неведении, что мир активен.

Запрещенная практика:

Generated java
// НЕПРАВИЛЬНО: Агент сам пытается отследить состояние
// В главном классе:
JOIN.register(handler -> { this.agent = new Agent(); });
// В классе Agent:
public Agent() { JOIN.register(handler -> { this.worldActive = true; }); } // НЕ СРАБОТАЕТ
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

Обязательная практика:

Generated java
// ПРАВИЛЬНО: Главный класс управляет состоянием агента
// В главном классе:
JOIN.register(handler -> {
    this.agent = new Agent();
    this.agent.setWorldActive(true); // Явно сообщаем агенту о состоянии
});
// В классе Agent:
public void setWorldActive(boolean active) { this.worldActive = active; }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

Контрольный список для AI:

Жизненный цикл объекта управляется событием X? -> Объект не должен сам подписываться на событие X.

Передается ли состояние объекту явно через публичные методы (setter-ы)?

Правило №4: Обеспечить идемпотентность и полную очистку ресурсов

Принцип: Любой ресурс, созданный или запущенный при входе в мир, должен быть полностью уничтожен или остановлен при выходе из него. Процесс "вход-выход" должен быть полностью обратимым.

Обоснование: Ошибка Your account is limited to 1 simultaneous ngrok agent sessions была прямо вызвана тем, что при выходе из мира освобождался только ключ ngrok, но сам фоновый процесс оставался работать.

Запрещенная практика: Выполнять неполную очистку, оставляя "висеть" процессы, потоки или обработчики.

Обязательная практика: В событии ServerLifecycleEvents.SERVER_STOPPING реализовать полную и последовательную процедуру очистки.

Контрольный список для AI:

Какие ресурсы были запущены при входе? (Потоки, процессы, агенты, флаги).

Содержит ли логика выхода явные команды для остановки каждого из этих ресурсов?

agent.shutdown()

ngrokProcess.kill()

executorService.shutdownNow()

agentInitialized = false


Является ли порядок очистки логичным (сначала остановить зависимые компоненты, потом основные)?